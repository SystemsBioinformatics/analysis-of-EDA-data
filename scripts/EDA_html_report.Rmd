---
title: "`r report_title`"
subtitle: "EDA Bioassay Analysis"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
params:
  pb_fm_data: pb_fm_data
  pb_p_data: pb_p_data
  ylab: ylab
  sample_fm_data: NULL
  sample_p_data: NULL
  sample_plate_id: NULL
  sd_threshold: 3
  plate_threshold: NULL
  normalization: FALSE 
  neg_control: NULL
  pos_control: NULL
  iteration_time: 60
  iteration1: 1
  iteration2: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, 
                      dev.args = list(png = list(type = "cairo")), dpi=300,
                      fig.align = "center")
```

```{r Information run}
# Create and print a table containing meta information about the assay run
if (all(c("meta1", "meta2") %in% names(params$pb_fm_data))){
  meta <- tibble::enframe(params$pb_fm_data$meta1) %>% # creates the 'value' as a `list` column
    mutate(value = purrr::map(value, as.character)) %>% # change to single type
    unnest(cols = c(value)) %>%
    bind_rows(tibble::enframe(params$pb_fm_data$meta2) %>% # creates the 'value' as a `list` column
                mutate(value = purrr::map(value, as.character)) %>% # change to single type
                unnest(cols = c(value))) %>%
    bind_rows(tibble::enframe(params$pb_fm_data$interpreted) %>% # creates the 'value' as a `list` column
                mutate(value = purrr::map(value, as.character)) %>% # change to single type
                unnest(cols = c(value))) %>%
    filter(name != "Spotlog format" & name != "Start Delay" & name != "Run folder" & name != "Wait on input") %>%
    drop_na()
} else {
  meta <- tibble::enframe(params$pb_fm_data$meta) %>%
    mutate(value = purrr::map(value, as.character)) %>% # change to single type
    unnest(cols = c(value)) %>%
    drop_na()
}

knitr::kable(meta, caption = "**Assay run information**", col.names = NULL)%>%
  kableExtra::kable_styling(full_width = F, font_size = 12)
```

All data is stored in the folder `r directory_name` in the working directory. 

```{r Data preprocessing}
# Check if a plate is measured more than once
# If a plate is measured more than once,
# calculate the slope of the fluorescence increase for each well
# The calculate_slopes function also combines the fractiomate data and
# platereader data into a single data frame
if ("m_iter" %in% colnames(params$pb_p_data) && max(as.numeric(params$pb_p_data$m_iter)) > 1){
  # Calculate the slopes
  data <- preprocess_multiple(params$pb_fm_data, params$pb_p_data, iteration_time = params$iteration_time, 
                              iter1 = params$iteration1, iter2 = params$iteration2,
                              plate_id = "PB")
  
  # slopes of the fractionated wells and
  # convert time to seconds
  fraction_data_pb <- data$fraction_data  %>%
    mutate(ready_time = as.numeric(as.duration(ready_time)))
    
  if ("start_time" %in% colnames(fraction_data_pb)){
    fraction_data_pb <- tibble(fraction_data_pb)  %>%
      mutate(start_time = as.numeric(as.duration(start_time)))
  }
  
  # slopes of the control wells
  control_data_pb <- data$control_data
  
  # Generate message explaining how the data is pre-processed
  m <- paste0("Data is pre-processed by calculating the slope of the fluorescence intensity over interval [", params$iteration1,
             ",", params$iteration2, "]. The time between each iteration is ", params$iteration_time, " seconds.")
  
  # Check if sample data is provided and calculate the slope of every well of all plates
  if (!is.null(params$sample_fm_data) && !is.null(params$sample_p_data)){
    fraction_data_sample <- list()
    control_data_sample <- list()
    
    # Here, the code iterates over the number of environmental sample replicates 
    # or samples that were defined and calculates the slope 
    # for the fractionated data and the control data for each replicate
    for (idx in 1:length(params$sample_fm_data)){ 
      # Calculate the slopes for every sample plate
      data <- preprocess_multiple(params$sample_fm_data[[idx]], params$sample_p_data[[idx]], iteration_time = params$iteration_time, 
                              iter1 = params$iteration1, iter2 = params$iteration2,
                              plate_id = params$sample_plate_id[idx])
  
      # slopes of the fractionated wells
      fraction_data_sample <- c(fraction_data_sample, list(data$fraction_data))
      
      # slopes of the control wells
      control_data_sample <- c(control_data_sample, list(data$control_data))
      
      }
    
    # Unnest control data from all samples/replicates into one data frame
    control_data_sample <- tibble(control_data_sample) %>%
      unnest(cols = c(control_data_sample))
    
    # Unnest fraction data from all samples/replicates into one data frame
    fraction_data_sample <- tibble(fraction_data_sample)  %>% 
      unnest(cols = c(fraction_data_sample)) %>%
      mutate(ready_time = as.numeric(as.duration(ready_time)))
    
    if ("start_time" %in% colnames(fraction_data_sample)){
      fraction_data_sample <- tibble(fraction_data_sample)  %>%
        mutate(start_time = as.numeric(as.duration(start_time)))
      }
  }
} else {
  # If a plate is measured just once,
  # fractiomate data and platereader data of the
  # procedure blank are combined into a single data frame 
  # and if necessary, pre-processed by subtracting the background
  # from the target signal
  data <- preprocess_single(params$pb_fm_data, params$pb_p_data, plate_id="PB")
  
  # convert time to seconds
  fraction_data_pb <- data$fraction_data   %>%
    mutate(ready_time = as.numeric(as.duration(ready_time)))
    
  if ("start_time" %in% colnames(fraction_data_pb)){
    fraction_data_pb <- tibble(fraction_data_pb)  %>%
      mutate(start_time = as.numeric(as.duration(start_time)))
  }
  
  control_data_pb <- data$control_data
  
  # Generate message explaining how the data is pre-processed
  if ("background" %in% params$pb_p_data$m_levels){
    m <- ("Fluorescence signal is corrected for background fluorescence by subtracting the background signal from the target signal.")
  } 

  # Combine sample platereader data and sample fractiomate data into a single data frame
  if (!is.null(params$sample_fm_data)){
    fraction_data_sample <- list()
    control_data_sample <- list()
    
    if (is.null(params$sample_p_data)){
      # Here, the code iterates over the number of environmental sample 
      # replicates or samples that were defined and preprocesses them by
      # subtracting the background
      for (idx in 1:length(params$sample_fm_data)){
        data <- preprocess_single(params$sample_fm_data[[idx]], params$pb_p_data, plate_id=sample_plate_id[idx])
        
        fraction_data_sample <- c(fraction_data_sample, list(data$fraction_data))
        control_data_sample <- c(control_data_sample, list(data$control_data))
      }
    } else {
      # Here, the code iterates over the number of environmental sample 
      # replicates or samples that were defined
      for (idx in 1:length(params$sample_fm_data)){
        data <- preprocess_single(params$sample_fm_data[[idx]], params$sample_p_data[[idx]], plate_id=sample_plate_id[idx])
        
        fraction_data_sample <- c(fraction_data_sample, list(data$fraction_data))
        control_data_sample <- c(control_data_sample, list(data$control_data))
      }
    }

      # Unnest control data from all samples/replicates into one data frame
      control_data_sample <- tibble(control_data_sample) %>%
        unnest(cols = c(control_data_sample))

      # Unnest fraction data from all samples/replicates into one data frame
      # and convert time to seconds
      fraction_data_sample <- tibble(fraction_data_sample)  %>% 
        unnest(cols = c(fraction_data_sample)) %>%
        mutate(ready_time = as.numeric(as.duration(ready_time)))
      
      if ("start_time" %in% colnames(fraction_data_sample)){
        fraction_data_sample <- tibble(fraction_data_sample)  %>%
          mutate(start_time = as.numeric(as.duration(start_time)))
      }
  }
}

```

`r if(exists("m")){paste(m, 'In this report, the pre-processed data will be refered to as observed data.')}`

<p>&nbsp;</p>

## Visual exploration of data

To get an initial understanding of the data, the observed fluorescence signal is plotted per well on the plate and per fraction in order of fractionation. By visualizing the data, biases that often occur in biological screening data, such as plate effects, can be easily detected.
The number of fractions in this assay run is `r nrow(fraction_data_pb)`. 

```{r Heatmap of raw/pre-processed data, fig.cap = "**Figure 1. Heatmap showing the observed bioassay signal of the procedure blank in each well of the 96-well plate.** The color of the wells indicate  the fluorescence signal.", fig.width = 7.5, fig.height = 5}

# Plot the fluorescence signal in a 2D heatmap that represents a micro-well plate
fig <- heatmap(fraction_data_pb, value = "raw_value", well = "m_well", title = "Bioassay response", subtitle = "of procedure blank", ylab = params$ylab)
fig

# Save plot
save_plot(fig, file.path(result_directory, "Figure 1"), width = 7.5, height = 5)
rm(fig)
```

<p>&nbsp;</p>

```{r Lineplot of raw/pre-processed data, fig.cap = "**Figure 2. The observed bioassay signal per fraction.** The fraction numbers are displayed on the x-axis in order of fractionation and the bioassay signal is displayed on the y-axis.", fig.width = 5, fig.height = 5, out.width = "75%", out.height = "75%"}

# Plot the fluorescence signal against time to
# determine if a time-dependent bias is present
fig <- scatterplot(fraction_data_pb, x = "m_fraction", y = "raw_value", title = "Bioassay response", subtitle = "of procedure blank", xlab = "Fraction", ylab = params$ylab)
fig

# Save plot
save_plot(fig, file.path(result_directory, "Figure 2"), width = 5, height = 5)
rm(fig)
```

## Bias reduction

To reduce bias present in the data, a curve is fitted through the data using a generalized additive model, or GAM. GAM captures relationships between independent and dependent variables in smooth functions. To predict the dependent variable, the smooth functions are estimated and then added up. Here, a GAM will be built using smooth functions for both plate and fractionation effect, as extracts are fractionated over the plate in a row- or column-wise snake-like pattern. For each effect, a smooth curve will be fitted and added up to obtain a smoother procedure blank or reference chromatogram. 
The GAM structure can be described as: $$E(assay~signal) = s(row, column) + s(fractionation)$$
$s(row, column)$ is the plate effect smooth term and $s(fractionation)$ is the fractionation effect smooth term.

### GAM results

```{r Run GAM}

# Fit the generalized additive model
GAMres <- run_GAM(fraction_data_pb)

# Produce a summary of the model and
# Check the significance of your smooth terms
gam_summary <- summary(GAMres$fit)
gam_summary
```

The first part of the summary of the results describes the model that is fitted. "Family" means that a Gaussian or normal distribution of the errors is assumed. The "Link" of "identity" tells us that the model does not transform the predictions. In the next section, the parametric terms of the model are described. Parametric in this context refers to linear terms. However,  no linear terms were added to the model, hence, only the intercept is mentioned in this section. The following section covers the smooth terms. For smooths, coefficients are not printed because each smooth function has multiple coefficients, one for each basis dimension (`k`). The basis dimension is partially responsible for the curvature of the fit. Instead of coefficients, the effective degrees of freedom (edf) are returned. The edf value represents the complexity of the smooth, i.e. an edf of 1 is equivalent to a straight line, while higher edfs describe more wiggly curves. The `p-value` explains the overall significance of the smooth. A non-significant `p-value` specifies a zero effect of the indicated smooth function. Inspecting the results, `p-value` = `r gam_summary$s.table[1,4]`  is reported for the first smoothing spline, which models the plate effect, and `p-value` = `r gam_summary$s.table[2,4]` is reported for the second spline, which describes the fractionation effect. 


#### Basis dimension check

As mentioned before, `k` is partially responsible for the curvature of the fit. It should not be too low because that prevents the model from being sufficiently wiggly. However, if `k` is too high, you might get a model with more parameters than data and that is too slow to fit. Hence, `k` should be large enough to get sufficient curves, but small enough to deter increased computational cost. Whether `k` is properly chosen can be determined by checking the adequateness of the basis dimensions. This reports the `k-index` estimate, which must not be far below 1, and a `p-value`, which must also not be too low, because a low p-value combined with a `k-index` below 1 may indicate that `k` is set too low, especially if the number of `k` is close to the reported effective degrees of freedom (edf). The basis dimension checking results are reported in Table 1.

```{r Basis dimension check}
# Check the basis dimensions and 
# Create a table of the result of the basis dimension check
k_idx <- k.check(GAMres$fit)
knitr::kable(k_idx, caption = "**Table 1. Basis dimension (k) results.**")
```

Inspecting the basis dimension (`k`) results, a `k-index` = `r  k_idx[5]` with  `p-value` = `r k_idx[7]` is reported for the first smooth term, i.e. the plate effect (Table 1). For the second smooth term, the fractionation effect, `k-index` = `r k_idx[6]` and `p-value` = `r k_idx[8]` are reported. A `k-index` estimate close to 1 or higher than 1 with a high `p-value` means that the basis dimension (`k`) used is of sufficient size. This suggests that the fit is stable and that the model represents the data well.

### Model assessment

To assess the appropriateness of the model, the residuals should be examined. The difference between the observed value of the dependent variable and the predicted value is called the residual. Each data point has one residual. To inspect the residuals, the observed values and the residuals will be plotted against the fitted values. In addition, the residuals are be plotted in a histogram to assess normality and determine a standard deviation. This standard deviation can be used to determine the Limit of Detection (LOD), which is the lowest assay signal that can be reliably distinguished from the null, or the procedure blank. 

```{r Diagnostic plots of residuals,  fig.cap = "**Figure 3. Diagnostic plots of the residuals of the model E(assay signal) = s(row, column) + s(fraction). A.** The fitted values plotted against the observed values. The fitted values are displayed on the x-axis and the observed values on the y-axis. **B.** The fitted values plotted against the residuals. The fitted values are displayed on the x-axis and the residuals on the y-axis. **C.** Q-Q plot of the residuals. The theoretical quantiles are plotted on the x-axis and the sample quantiles on the y-axis. **D.** The distribution of the residuals. The residuals are displayed on the x-axis and the frequency and density on the right and left y-axis, respectively. SD is the standard deviation.", fig.width = 10, fig.height = 9}

# Calculate the residuals by subtracting the
# fitted procedure blank data from the raw dta and
# produce diagnostic plots of the residuals
# to assess the model
nd <- GAMres$fitted_data %>%
  inner_join(fraction_data_pb) %>%
  mutate(residuals = raw_value - fitted_value)

fig <- residuals_diagnostic_plot(nd)

fig

# Save plot
save_plot(fig, file.path(result_directory, "Figure 3"), width = 10, height = 9)
rm(fig)
```

In case, the residuals are also plotted against the independent variables (plate and fraction numbers) to see if there might be a pattern present. The residuals should be randomly distributed over the plate and over time.

```{r Heatmap residual vs. independent variable 1, fig.cap = "**Figure 4. Heatmap of the distribution of residuals over the 96-well plate.**", fig.width = 7.5, fig.height = 5}

# Plot the residuals in a 2D heatmap to determine whether
# the residuals are randomly distributed within the plate
fig <- heatmap(nd, value = "residuals", well = "m_well", title = "Residuals")
fig

# Save plot
save_plot(fig, file.path(result_directory, "Figure 4"), width = 7.5, height = 5)
rm(fig)
```

<p>&nbsp;</p>

```{r Lineplot residuals vs. independent variable 2, fig.cap = "**Figure 5. The residuals per fraction.** The fraction numbers are displayed on the x-axis in fractionation order and the residuals are displayed on the y-axis.", fig.width = 5, fig.height = 5, out.width = "75%", out.height = "75%"}

# Plot the residuals against the predictor variable time
fig <- scatterplot(nd, x = "m_fraction", y = "residuals", title = "Residuals", xlab = "Fraction", ylab = "Residuals", line = FALSE) +
    geom_hline(yintercept = 0, linetype="dashed", color = "red")
fig

# Save plot
save_plot(fig, file.path(result_directory, "Figure 5"), width = 5, height = 5)
rm(fig)
```

### Single smooth effects

To determine the effect of each smooth function individually, plots of the individual fractionation effect and plate effect are plotted here. 

```{r Determine and plot individual smooth effects, fig.cap = "**Figure 6. The individual effects of the component smooth functions that make up the model. A.** Heatmap of the plate effect (s(row, column)). The color of the wells represent the magnitude of the effect. **B.** Lineplot of the fractionation effect (s(fractionation)). The fraction numbers are displayed on the x-axis in order of fractionation and the magnitude of the effect is displayed on the y-axis.", fig.width = 10, fig.height = 5}
# Here, the effect of each smooth term is extracted from the GAM object
# and plotted to assess the individual effects

# Calculate effect of the spatial bias smooth function
effect <- calculate_effect(GAMres$fit)

p1 <- heatmap(effect$plate_effect, "value", "m_well", title = "Plate effect", ylab = "Effect")

# Calculate effect of the time effect smooth function
effect$time_effect <- effect$time_effect %>%
  inner_join(nd %>%
               select(m_fraction, m_well)) # add well labels to the time effect data frame

p2 <- scatterplot(effect$time_effect, "m_fraction", "value", title = "Time effect", ylab = "Effect", xlab = "Fraction")

# Combine effects into a single plot
fig <- annotate_figure(ggarrange(p1, p2, ncol=2, labels = c("A","B")), 
                     top = text_grob("Smooth effects", size = 17.5, hjust=0.325, face="bold"))

fig

# Save plot
save_plot(fig, file.path(result_directory, "Figure 6"), width = 10, height = 5)
rm(fig, p1, p2)
``` 


### Autocorrelation of residuals

To further evaluate the model, the assumption of no autocorrelation in the residuals should be checked. Autocorrelation means that a value is correlated with a previous value, which is not expected for the residuals because they should follow a random pattern. When autocorrelation is detected in the residuals from the model, it suggests that the model is misspecified. A cause could be that there is some information left over that was not accounted for in the model. The partial autocorrelation function measures the correlation between a value and a previous value while removing the correlation of the intervening observations.

```{r, Calculate and plot autocorrelations, fig.cap = "**Figure 7. Autocorrelation and partial autocorrelation plots of the residuals. A.** Autocorrelation plot. The x-axis displays the lag between the residuals and the y-axis the value of the autocorrelation function. The autocorrelation with lag zero always equals 1, because this represents the autocorrelation between each residual and itself. **B.** Partial autocorrelation plot. The x-axis displays the lag between the residuals and the y-axis the value of the partial autocorrelation function. The blue dashed lines represent the 95% confidence interval (CI).", fig.width = 10, fig.height = 5}
# Compute the autocorrelation and partial autocorrelation
# estimates of the residuals and plot them
autocorr_results <- autocorr(nd$residuals)

autocorr_results$fig

save_plot(autocorr_results$fig, file.path(result_directory, "Figure 7"), width = 10, height = 5)
```

## Observed procedure blank versus fitted

The observed procedure blank chromatogram is plotted together with the fitted procedure blank chromatogram to be able to compare them and detect possible patterns that might be present in the fitted chromatogram.

```{r Lineplot of raw/pre-processed and fitted values versus fraction numbers, fig.cap = "**Figure 8. The observed procedure blank and fitted procedure blank bioassay signals per fraction.** The x-axis represents fraction numbers in fractionation order and the y-axis the bioassay signal. The fitted chromatogram is depicted in dark purple and the observed chromatogram in yellow.", fig.width = 5, fig.height = 5, out.width = "75%", out.height = "75%"}

# Plot the observed procedure blank chromatogram and the fitted 
# procedure blank chromatogram in a single plot
nd_long <- nd %>%
  gather(key = "line", value = "value", raw_value, fitted_value) %>% # gather observed and fitted columns into one
  mutate(line=case_when(line == "raw_value" ~ "Observed PB",
                        TRUE ~ "Fitted PB"))

fig <- scatterplot(nd_long, x = "m_fraction", y = "value", col = "line", title = "Bioassay response", subtitle = "of observed and fitted procedure blank", xlab = "Fraction", ylab = params$ylab)
fig

# Save plot
save_plot(fig, file.path(result_directory, "Figure 8"), width = 5, height = 5)
rm(fig, nd_long)
```

```{r Normalization of procedure blank, eval = params$normalization}

#!! This chunk is only evaluated if normalization is TRUE

# Normalize the procedure blank data, including raw/pre-processed and fitted data
# Then calculate the normalized residuals by subtracting the normalized fitted values from the normalized raw/pre-processed values
nd <- normalize(nd, c("raw_value", "fitted_value"), control_data_pb, params$neg_control, params$pos_control)

nd <- nd %>%
  mutate(norm_residuals = norm_raw_value - norm_fitted_value)
```

<p>&nbsp;</p>

`r if(params$normalization & !is.null(params$neg_control) & !is.null(params$pos_control)){"Fraction data is normalized to the negative and positive control using the following formula: <math><mfrac><mi>fraction signal - postive control signal</mi><mi>negative control signal - positive control signal</mi></mfrac></math> ⋅ 100. Normalized data is used for further analysis."}`

`r if(params$normalization & !is.null(params$neg_control) & is.null(params$pos_control)){"Fraction data is normalized to the negative control using the following formula: <math><mfrac><mi>fraction signal</mi><mi>negative control signal</mi></mfrac></math> ⋅ 100. Normalized data is used for further analysis."}`

`r if(params$normalization & is.null(params$neg_control) & !is.null(params$pos_control)){"Fraction data is normalized to the positive control using the following formula: <math><mfrac><mi>fraction signal</mi><mi>positive control signal</mi></mfrac></math> ⋅ 100. Normalized data is used for further analysis."}`

```{r Calculate descriptive statistics}

# Calculate descriptive statistics for the residuals of the procedure blank
# If data is normalized, this is also done for the normalized residuals
if (params$normalization){
  descriptives <- nd %>%
    select(residuals, norm_residuals) %>%
    gather(key = "type", value = "value") %>%
    group_by(type) %>%
    summarise(Min.=min(value), `1st Qu.`= quantile(value, 0.25), SD=sd(value), 
              Median=median(value), MAD=mad(value), `3rd Qu.`= quantile(value, 0.75),
            Max.=max(value)) %>%
    ungroup %>%
    mutate(type = case_when(type == "norm_residuals" ~ "Normalized residuals",
                            TRUE ~ "Residuals"))
} else {
    descriptives <- nd %>%
    select(residuals) %>%
    summarise(Min.=min(residuals), `1st Qu.`= quantile(residuals, 0.25), SD=sd(residuals), Median=median(residuals), 
              MAD=mad(residuals), `3rd Qu.`= quantile(residuals, 0.75),
              Max.=max(residuals))
}

# Create a table with the descriptive statistics of the residuals of the procedure blank
knitr::kable(descriptives %>%
    mutate_if(is.numeric, round, digits = 2), caption = "**Table 2. Descriptive statistics of residuals.**")
```

```{r Save PB data}

# Reorder the results to create a clear table of the data
# Save this procedure blank data by writing it to an Excel file
if (params$normalization){
  nd <- nd %>%
    mutate(SD = sd(residuals), norm_SD = sd(norm_residuals)) %>%
    select(m_row, m_col, m_fraction, m_well, any_of("start_time"),
           ready_time, raw_value, fitted_value, residuals, SD,
           norm_raw_value, norm_fitted_value, norm_residuals, norm_SD)
} else{
    nd <- nd %>%
    mutate(SD = sd(residuals)) %>%
    select(m_row, m_col, m_fraction, m_well, any_of("start_time"),
           ready_time, raw_value, fitted_value, residuals, SD)
}

writexl::write_xlsx(nd, file.path(result_directory, "procedure_blank_results.xlsx"))
```

<p>&nbsp;</p>

`r if(!is.null(params$sample_fm_data)){"## Hit selection\\n"}`

`r if(!is.null(params$sample_fm_data) & normalization){"To determine whether plate and time effects that are present in the procedure blank data are also present in the sample or replicate data, the bioassay response is visualized in plate format and per fraction in fractionation order. The control-based normalized values are plotted here."}`

`r if(!is.null(params$sample_fm_data) & !normalization){"To determine whether plate and time effects that are present in the procedure blank data are also present in the sample or replicate data, the bioassay response is visualized in plate format and per fraction in fractionation order. The raw/pre-processed (non-normalized) values are plotted here."}`

<p>&nbsp;</p>

```{r Sample visualization dimensions, eval = !is.null(params$sample_fm_data)}

#!! This chunk is only evaluated when sample data is provided next to procedure blank data

# Set the dimensions for the sample visualizations
# to print them with high quality
if (!is.null(params$sample_fm_data)){
  if (nlevels(as.factor(fraction_data_sample$m_plate)) == 1){
    height <- 5
    width <- 7.5
  } else if (nlevels(as.factor(fraction_data_sample$m_plate)) %in% c(2,3)){
    height <- 7
    width <- 8
  } else if (nlevels(as.factor(fraction_data_sample$m_plate)) %in% c(4,5)){
    height <- 9.5
    width <- 7.5
  } else if (nlevels(as.factor(fraction_data_sample$m_plate)) == 6){
    height <- 12.5
    width <- 7.5
  }
}

hit.plot.dim <- c(width, height)
```

```{r Heatmaps of bioassay signal of samples/replicates, eval = !is.null(params$sample_fm_data), fig.cap = paste('**Figure 9. Bioassay response of procedure blank and', ifelse(is.null(params$plate_threshold), 'samples', 'replicates'), 'per well in the 96-well plate.** The plates are labelled with their plate ID. Plate "PB" is the procedure blank. The procedure blank heatmap may look different from Figure 1 due to a larger scale range.'), fig.width = {if (exists("hit.plot.dim")) hit.plot.dim[1] else 5}, fig.height = {if (exists("hit.plot.dim")) hit.plot.dim[2] else 5}, out.width = {if (exists("fraction_data_sample") && nlevels(as.factor(fraction_data_sample$m_plate)) == 1) "75%" else "100%"}, out.height = {if (exists("fraction_data_sample") && nlevels(as.factor(fraction_data_sample$m_plate)) == 1) "75%" else "100%"}}

#!! This chunk is only evaluated when sample data is provided next to procedure blank data

# Combine sample data with the fitted procedure blank data
fraction_data_sample <- fraction_data_sample %>%
inner_join(nd %>%
             select(m_row, m_col, m_fraction, m_well, fitted_pb_value = fitted_value,
                    raw_pb_value = raw_value, residuals))

# Normalize sample data if normalization is TRUE
# Correct for procedure blank by subtracting the sample 
# fluorescence signal from it
# Calculate the threshold standard deviation
if (params$normalization) {
  fraction_data_sample <- normalize(fraction_data_sample, "raw_value", control_data_sample, params$neg_control, 
                                    params$pos_control) %>%
    inner_join(nd %>%
                 select(m_fraction, norm_fitted_pb_value = norm_fitted_value, 
                      norm_raw_pb_value = norm_raw_value, norm_residuals)) %>%
    mutate(fitted_signal = norm_fitted_pb_value - norm_raw_value,
           threshold = params$sd_threshold * sd(norm_residuals))
  
  # gather data of procedure blank and samples/replicates in long format to make plotting easier
  plot.data <- tibble(m_plate = "PB", value = nd$norm_raw_value, m_well = nd$m_well, m_fraction = nd$m_fraction) %>%
    bind_rows(fraction_data_sample %>%
                mutate(m_plate = as.character(m_plate)) %>%
                select(m_plate, value = norm_raw_value, m_well, m_fraction)) %>%
    mutate(m_plate = factor(m_plate, levels = c("PB", unique(m_plate[m_plate != "PB"]))))
  
} else {
  fraction_data_sample <- fraction_data_sample %>%
    mutate(fitted_signal = fitted_pb_value - raw_value,
           threshold = params$sd_threshold * sd(residuals))
  
  # gather data of procedure blank and samples/replicates in long format to make plotting easier
  plot.data <- tibble(m_plate = "PB", value = nd$raw_value, m_well = nd$m_well, m_fraction = nd$m_fraction) %>%
    bind_rows(fraction_data_sample %>%
                mutate(m_plate = as.character(m_plate)) %>%
                select(m_plate, value = raw_value, m_well, m_fraction)) %>%
    mutate(m_plate = factor(m_plate, levels = c("PB", unique(m_plate[m_plate != "PB"]))))
}



fig <- heatmap(plot.data, value = "value", well = "m_well", title = "Bioassay response", subtitle = paste("of the procedure blank &", ifelse(is.null(params$plate_threshold), 'samples', 'replicates')), ylab = paste0(params$ylab, ifelse(normalization, "\n(% of control)", "")), multiple = TRUE, plate_id = "m_plate")

fig
save_plot(fig, file.path(result_directory, "Figure 9"), width = hit.plot.dim[1], height = hit.plot.dim[2])
rm(fig)
```

```{r Sample line plots, eval = !is.null(params$sample_fm_data), fig.cap = paste('**Figure 10. Bioassay response of procedure blank and', ifelse(is.null(params$plate_threshold), 'samples', 'replicates'), 'per fraction.** The x-axis represents fraction numbers in fractionation order and the y-axis represents the bioassay signal. The color of the lines represent the plate. Plate "PB" is the procedure blank.'), fig.width = 5, fig.height = 5, out.width = "75%", out.height = "75%"}

#!! This chunk is only evaluated when sample data is provided next to procedure blank data

fig <- scatterplot(plot.data, x = "m_fraction", y = "value", col = "m_plate", title = "Bioassay response", subtitle = paste("of the procedure blank &", ifelse(is.null(params$plate_threshold), 'samples', 'replicates')), xlab = "Fraction", ylab = paste0(params$ylab, ifelse(normalization, "\n(% of control)", "")))


fig
save_plot(fig, file.path(result_directory, "Figure 10"), width = 5, height = 5)
rm(plot.data, fig)
```

<p>&nbsp;</p>

`r if(!is.null(params$sample_fm_data) & normalization){paste0("From the normalized residuals of the procedure blank, a standard deviation is determined. This standard deviation can be used as a measure on how much the sample extract assay signal differs from the null, i.e. the procedure blank (Limit of Detection). To be able to detect peaks, the sample extract values were subtracted from the normalized fitted procedure blank values. The LOD is set at ", params$sd_threshold, " SD, which means that peaks that exceeded the threshold of ", params$sd_threshold, " SD are considered bioactive.")}`

`r if(!is.null(params$sample_fm_data) & !normalization){paste0("From the residuals of the procedure blank, a standard deviation is determined. This standard deviation can be used as a measure on how much the sample extract assay signal differs from the null, or the procedure blank (Limit of Detection). To be able to detect peaks, the sample extract values were subtracted from the fitted procedure blank values. The LOD is set at ", params$sd_threshold, " SD, which means that peaks that exceeded the threshold of ", params$sd_threshold, " SD are considered bioactive.")}`

`r if(!is.null(params$sample_fm_data) &!is.null(plate_threshold)){paste0("Since there are replicates in this case, peaks should exceed the standard deviation threshold in at least ", params$plate_threshold, " replicates")}`

<p>&nbsp;</p>

```{r Hit plot dimensions, eval = !is.null(params$sample_fm_data)}

#!! This chunk is only evaluated when sample data is provided next to procedure blank data

# Set the dimensions for the hit plots
# to print them with high quality
if (!is.null(params$sample_fm_data)){
  if (nlevels(as.factor(fraction_data_sample$m_plate)) == 1){
    n.col <- 1
    height <- 5
    width <- 5
  } else {
    n.col <- 2
    width <- 2*5
    height <- 0
    for (a in 2:6){
      if (a %% 2 == 0 && a != 2){
        height <- height + 5
      } else{
        height <- height
      }
    }
  }
}

hit.plot.dim <- c(width, height)
```

```{r Bioactive hit selection, eval = !is.null(params$sample_fm_data), fig.cap = paste("**Figure 11. Bioassay response of sample", paste(params$sample_plate_id, collapse = ', '), "after subtracting them from the procedure blank.** The fraction numbers are displayed on the x-axis and the blank corrected bioassay signal on the y-axis. The plot is labeled with the plate ID at the top. The horizontal lines represent the LOD (", params$sd_threshold, " SD). Fractions whose signal exceeds the ", params$sd_threshold, " SD threshold in the positive direction are marked blue and in the negative direction are marked yellow."), fig.width = {if (exists("hit.plot.dim")) hit.plot.dim[1] else 5}, fig.height = {if (exists("hit.plot.dim")) hit.plot.dim[2] else 5}, out.width = {if (exists("fraction_data_sample") && nlevels(as.factor(fraction_data_sample$m_plate)) == 1) "75%" else "100%"}, out.height = {if (exists("fraction_data_sample") && nlevels(as.factor(fraction_data_sample$m_plate)) == 1) "75%" else "100%"}}

#!! This chunk is only evaluated when sample data is provided next to procedure blank data

# Hit selection
# Fractions are selected if their procedure blank corrected
# signal equals or exceeds the standard deviation threshold or
# limit of detection. 
# In the case of replicates,
# the fractions must be selected as hits in a at least a certain number of replicates.
# This threshold is set using the plate_threshold parameter
hits <- fraction_data_sample %>%
  group_by(m_plate) %>%
  mutate(hit = case_when(fitted_signal >= threshold ~ 1, # fractions that exceed threshold in positive direction
                         fitted_signal <= -threshold ~ -1, # fractions that exceed threshold in negative direction
                         TRUE ~ 0)) %>%
  ungroup() %>%
  filter(hit != 0) # Remove fractions that were not selected as hits in a single replicate

# In case of replicates, select fractions that exceed
# limit of detection in a defined number of plates (plate_threshold)
if (!is.null(plate_threshold)){
  hits <- hits %>%
    group_by(m_fraction, hit) %>%
    filter(abs(sum(hit)) >= params$plate_threshold) %>% 
    mutate(direction = case_when(sum(hit) >= params$plate_threshold ~ "positive", # label direction of hits
                                 TRUE ~ "negative")) %>%
    ungroup()
} else {
  hits <- hits %>%
    filter(hit != 0) %>%
    mutate(direction = case_when(hit == 1 ~ "positive", # label direction of hits
                                 TRUE ~ "negative"))
}
  

# Rename column "threshold" to the threshold of standard deviations
names(fraction_data_sample)[names(fraction_data_sample) == "threshold"] <- paste0("+/- ", params$sd_threshold, "SD")

# Extract standard deviation data
# This will be used to set the boundaries in the plots
sd_data <- fraction_data_sample[,colnames(fraction_data_sample) %in% c("m_fraction", "m_plate", 
                                                                       paste0("+/- ", params$sd_threshold, "SD"))] %>%
  gather(key = "SD", value = "value", -c(m_fraction, m_plate))

# Plot the procedure blank corrected chromatograms to identify bioactive peaks
fig <- scatterplot(fraction_data_sample, x = "m_fraction", y = "fitted_signal", title = "Bioassay response", 
                subtitle = "after procedure blank subtraction", xlab = "Fraction", 
                ylab = {if (params$normalization) paste0(params$ylab, "\n(% of control)") else params$ylab}) +
  geom_line(data = sd_data, aes(x=m_fraction, y = value, col = as.factor(SD)), 
          alpha=1, size=0.35) + # add positive standard deviation lines to the plot
  geom_line(data = sd_data, aes(x = m_fraction, y = - value, col = as.factor(SD)), 
          alpha=1, size=0.35) # add negative standard deviation line to the plot 
  
# If there are hits, they will be marked
# Hits in the positive direction are marked
# in blue and in the negative direction in
# yellow
if (nrow(hits) >= 1){
  fig <- fig +
    geom_point(data = hits[hits$direction == "positive",], aes(x = m_fraction, y = fitted_signal), 
           color=viridis(3)[2], size=2) + # mark bioactive hits in the positive direction
    geom_point(data = hits[hits$direction == "negative",], aes(x = m_fraction, y = fitted_signal), 
           color=viridis(3)[3], size=2) + # mark bioactive hits in the negative direction  
    facet_wrap(~ m_plate, ncol = n.col)
} else{
  fig <- fig +
    facet_wrap(~ m_plate, ncol = n.col)
}
   

fig
save_plot(fig, file.path(result_directory, "Figure 11"), width = hit.plot.dim[1], height = hit.plot.dim[2])
rm(fig)

```
<p>&nbsp;</p>
```{r save scoring results, eval = !is.null(params$sample_fm_data)}

#!! This chunk is only evaluated when sample data is provided next to procedure blank data

# Rename column "threshold" to the threshold of standard deviations
names(hits)[names(hits) == "threshold"] <- paste0(params$sd_threshold, "SD")

# Rename and select columns that will be in the results Excel file
hits <- hits %>%
  select(Row = m_row, Column = m_col, Fraction = m_fraction, Well = m_well, Plate = m_plate, `Start time (sec.)` = any_of("start_time"), 
         `Ready time (sec.)` = ready_time, `Observed PB` = raw_pb_value, `Fitted PB` = fitted_pb_value, Residuals = residuals, 
         `Norm. Observed PB` = any_of("norm_raw_pb_value"), `Norm. Fitted PB` = any_of("norm_fitted_pb_value"), 
         `Norm. Residuals` = any_of("norm_residuals"), Signal = raw_value, `Blank Corrected Signal` = fitted_signal, 
         paste0(params$sd_threshold, "SD"), Direction = direction) %>% 
  mutate(Direction = factor(Direction, levels = c("positive", "negative"))) %>%
  arrange(Direction, Plate, Fraction)

# Create a table of the results
knitr::kable(hits %>%
  select(Fraction, Well, Plate, any_of("Start time"), `Ready time (sec.)`, `Blank Corrected Signal`, paste0(params$sd_threshold, "SD"), Direction), 
  caption = paste0('**Table 3. Bioassay identified hits.** Fractions whose bioassay signal exceeds the LOD ', 
  paste0('(', params$sd_threshold, ' SD)'), '. "Signal" is the bioassay signal subtracted from the fitted procedure blank. "Direction" indicates the direction of the peak.'))

# Save the hit selection data by writing it to an Excel file
writexl::write_xlsx(hits, file.path(result_directory, "scoring_results.xlsx"))  
```

